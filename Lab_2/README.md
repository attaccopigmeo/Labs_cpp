# Лабораторная работа № 2 (Шмидт Камилла, ИТ-7, Вариант-10)
## Задание 1. Заполнение и доступ к элементам. Обратные итераторы -- 7
### Условие
Даны вектор V, дек D и список L. Каждый исходный контейнер содержит не менее двух элементов,
количество элементов является четным. Поменять значения двух средних элементов каждого из
исходных контейнеров. Использовать алгоритм swap (не путать его с одноименной функцией-членом контейнера).
### Решение
Для дека и вектора меняем местами элемента с номерами `size / 2 - 1` и `size / 2`. Для списка из-за невозможности индексации требуется с начала пошагово продвигать итератор на `size / 2 - 1` элементов вперёд. Далее мы вставляем следующий за этим элемент перед предыдущим и удаляем следующий элемент.
### Тесты
Введите размер дека (четное число): 10
Введите элемент: 1
Введите элемент: 2
Введите элемент: 3
Введите элемент: 4
Введите элемент: 5
Введите элемент: 6
Введите элемент: 7
Введите элемент: 8
Введите элемент: 9
Введите элемент: 10
Введите размер списка (четное число): 10
Введите элемент: 1
Введите элемент: 2
Введите элемент: 3
Введите элемент: 4
Введите элемент: 5
Введите элемент: 6
Введите элемент: 7
Введите элемент: 8
Введите элемент: 9
Введите элемент: 10
Введите размер массива (четное число): 10
Введите элемент: 1
Введите элемент: 2
Введите элемент: 3
Введите элемент: 4
Введите элемент: 5
Введите элемент: 6
Введите элемент: 7
Введите элемент: 8
Введите элемент: 9
Введите элемент: 10
Элементы дека: 1 2 3 4 6 5 7 8 9 10 
Элементы списка: 1 2 3 4 6 5 7 8 9 10
Элементы массива: 1 2 3 4 6 5 7 8 9 10
## Задание 2. Вставка элементов -- 2
### Условие
Дан дек D с нечетным количеством элементов N(≥5). Добавить в начало дека пять его средних
элементов в исходном порядке. Использовать один вызов функции-члена insert.
### Решение
Заметим, что искомые элементы - это диапазон (N/2 - 2; N/2 + 3). Таким образом, нам достаточно выполнить insert, передав в качестве итератора начала begin() + N/2 - 2 (тем самым получив итератор на элементN/2 - 2), а в качестве итератора конца begin() + N/2 + 3.
### Тесты
Введите размер дека (нечетное число): 5
Введите элемент: r
Неверный ввод
Введите элемент: 3r
Неверный ввод
Введите элемент: 1
Введите элемент: 2
Введите элемент: 3
Введите элемент: 4
Введите элемент: 5
Получившийся дек: 1 2 3 4 5 
## Задание 3. Удаление элементов -- 10
### Условие
Дан список L с элементами A1, A2, A3, …, AN−1, AN (N — четное). Изменить порядок элементов в
списке на следующий: AN, A1, AN−1, A2, AN−2, …, AN/2, AN/2−1. Для этого использовать два
итератора i и r, связав их с первым и последним элементом списка. В цикле, который должен
повторяться N/2 раз, вызывать функцию-член splice с первым параметром i++ и третьим
параметром r--.
### Решение
Выполняем N/2 раз splice. В качестве первого аргумента передаем итератор i, который последовательно перемещается вперёд. В качестве третьего аргумента передаём итератор r, который всё время указывает на последний элемент списка. Таким образом достигается искомая расстановка.
### Тесты
Введите размер списка (четное число): 8
Введите элемент: 1
Введите элемент: 2
Введите элемент: 3
Введите элемент: 4
Введите элемент: 5
Введите элемент: 6
Введите элемент: 7
Введите элемент: 8
Получившийся список: 8 1 7 2 6 3 5 4
## Задание 4. Итераторы и алгоритмы -- 2
### Условие
Дан текстовый файл с именем name, содержащий строковые представления целых чисел.
Вывести числа из исходного файла с нечетными порядковыми номерами (т. е. первое число,
третье число и т. д.). Использовать алгоритм remove_copy_if.
### Решение
Считываем текстовый файл, после чего используем `remove_copy_if`. В качестве функционального объекта задаётся лямбда-функция, содержащая внутри себя переменную-счётчик, увеличивающийся при каждой проверке - он и обеспечивает выполнение условия.
### Тесты
*Содержимое файла name.txt:*
5
13
-1
64
42
105
-11
*Вывод программы:*
5 -1 42 -11
## Задание 5. Алгоритмы поиска -- 1
### Условие
Дан вектор V. Удалить второй из элементов вектора, равных нулю. Если нулевых элементов
меньше двух, то вектор не изменять. Использовать два вызова алгоритма find и функцию-член
erase.
### Решение
Сначала находим первый элемент вектора, равный нулю. Получаем итератор `first`, указывающий на него. После этого производим поиск повторно в диапазоне `[first + 1; end())`. Первый 0 в этом диапазоне будет вторым нулём во всём векторе, таким образом, получив итератор `second`, указывающий на него, удаляем элемент.
### Тесты
Введите размер вектора: а
Неверный ввод
Введите размер вектора: 10
Введите элемент: 1
Введите элемент: 2
Введите элемент: 3
Введите элемент: 0
Введите элемент: 4
Введите элемент: 5
Введите элемент: х
Неверный ввод
Введите элемент: 0
Введите элемент: 6
Введите элемент: 7
Введите элемент: 8
Получившийся вектор: 1 2 3 0 4 5 6 7 8
## Задание 6. Базовые модифицирующие алгоритмы. Итераторы вставки -- 10
### Условие
Дан вектор V с четным количеством элементов. В первой половине исходного вектора заменить
все отрицательные числа на −1, а во второй — все положительные числа на 1. Использовать два
вызова алгоритма replace_if с различными параметрами — функциональными объектами.
### Решение
Сначала получаем итератор `mid`, указывающий на правый из средних элементов. Далее первый вызов `replace_if` работает в диапазоне `[begin(); mid)` (т.е. в первой половине), а второй - в диапазоне `[mid; end())` (т.е. во второй половине), выполняя задачи из условия.
### Тесты
Введите размер вектора: а
Неверный ввод
Введите размер вектора: 9
Количество элементов должно быть чётное.
Введите размер вектора: 10
Введите элемент: 1
Введите элемент: -2
Введите элемент: 3
Введите элемент: х
Неверный ввод
Введите элемент: -4
Введите элемент: 5
Введите элемент: -6
Введите элемент: 7
Введите элемент: -8
Введите элемент: 9
Введите элемент: -10
Получившийся вектор: 1 -1 3 -1 5 -6 1 -8 1 -10
## Задание 7. Сортировка и слияние -- 7
### Условие
Дан список L. Перегруппировать элементы списка, расположив в нам вначале отрицательные,
затем нулевые, а затем положительные элементы (порядок расположения элементов в каждой
группе должен совпадать с исходным). Использовать два вызова алгоритма stable_partition.
### Решение
Первый вызов `stable_partition` разделяет элементы на отрицательные и неотрицательные, сохраняя относительный порядок в каждой группе. Второй вызов разделяет элементы на неположительные и положительные, сохраняя относительный порядок. Тогда нулевые элементы окажутся справа от отрицательных (из первого вызова) и слева от положительных (из второго вызова) - это и даст искомый порядок.
### Тесты
Введите размер вектора: а
Неверный ввод
Введите размер списка: 10
Введите элемент: 0      
Введите элемент: 1
Введите элемент: -2
Введите элемент: 3 
Введите элемент: -4
Введите элемент: 5
Введите элемент: х
Неверный ввод
Введите элемент: -6
Введите элемент: 7
Введите элемент: -8
Введите элемент: 9
Получившийся список: -2 -4 -6 -8 0 1 3 5 7 9
## Задание 8. Численные алгоритмы -- 1
### Условие
Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего
арифметического для всех пар соседних элементов исходного списка (количество элементов
вектора V должно быть на 1 меньше количества элементов списка L). Например, для исходного
списка 1, 3, 4, 6 полученный вектор должен содержать значения 2.0, 3.5, 5.0. Использовать
алгоритм adjacent_difference с итератором вставки и функциональным объектом, а также функцию-член erase для вектора V.
### Решение
Функция `adjacent_difference` производит последовательное вычисление заданной функции на каждой паре соседних элементов. Мы задали функцию вычисления среднего арифметического. Однако, первым элементом нового вектора становится результат вычисления функции от первого элемента списка и нуля - такой элемент мы удаляем.
### Тесты
Введите размер вектора: а
Неверный ввод
Введите размер списка: 4
Введите элемент: 1
Введите элемент: х
Неверный ввод
Введите элемент: 3
Введите элемент: 4
Введите элемент: 6
Получившийся вектор: 2 3.5 5
## Задание 9. Множества -- 1
### Условие
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0
не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N,
в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе
вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I = 1, …, N.
### Решение
Считываем вектор V0 и сортируем его (это требуется для `includes`). Далее, введя счётчик подходящих векторов. поочерёдно считываем каждый вектор v1,...,VN, сортируем его и применяем `includes`. В случае, если `includes`, возвращает `true`, увеличиваем счётчик.
### Тесты
Введите размер вектора V0: а
Неверный ввод
Введите размер вектора V0: 3
Введите элемент: 2  
Введите элемент: х
Неверный ввод  
Введите элемент: 3
Введите элемент: 1
Введите количество векторов в наборе: 4
Введите размер вектора V1: b
Неверный ввод
Введите размер вектора V1: 1
Введите элемент: 1
Введите размер вектора V2: 5
Введите элемент: 1
Введите элемент: 2
Введите элемент: 3
Введите элемент: 4
Введите элемент: х
Неверный ввод
Введите элемент: 5
Введите размер вектора V3: 3
Введите элемент: 3
Введите элемент: 2
Введите элемент: 4
Введите размер вектора V4: 8
Введите элемент: 3
Введите элемент: 4
Введите элемент: 5
Введите элемент: 2
Введите элемент: 7
Введите элемент: 8
Введите элемент: 7
Введите элемент: 1
Количество искомых векторов: 2
## Задание 10. Отображения -- 2
### Условие
Дан вектор V, элементами которого являются английские слова, набранные заглавными
буквами. Определить суммарную длину слов, начинающихся с одной и той же буквы, и вывести
все различные буквы, с которых начинаются элементы вектора V, вместе с суммарной длиной
этих элементов (в алфавитном порядке букв); длину выводить сразу после соответствующей
буквы. Использовать вспомогательное отображение M, ключами которого являются начальные
буквы элементов вектора V, а значениями — суммарная длина этих элементов. При заполнении
отображения M не использовать условные конструкции (достаточно операций индексирования
[], инкремента и функции-члена size для строк). Элементы вектора V (при заполнении
отображения M) и элементы отображения M (при выводе полученных результатов) перебирать
в цикле с параметром-итератором соответствующего контейнера.
### Решение
Считываем вектор слов, после чего заводим отображение из `char` в `size_t`. Для каждого слова увеличиваем элемент отображения по ключу - первой букве на длину слова. Отметим, что отображение в случае отсутствия нужной буквы автоматически добавит в себя нужную запись со значением по умолчанию 0. В конце перебираем отображение (записи в нём автоматически сортируются по ключам-буквам).
### Тесты
Введите размер вектора: а
Неверный ввод
Введите размер вектора: 10
Введите элемент: ADD
Введите элемент: SUBTRACT
Введите элемент: MULTIPLY
Введите элемент: DIVIDE
Введите элемент: APPEND
Введите элемент: SELECT
Введите элемент: MOVE
Введите элемент: RESET
Введите элемент: DELETE
Введите элемент: DROP
Суммарные длины слов по буквам:
A 9
D 16
M 12
R 5
S 14